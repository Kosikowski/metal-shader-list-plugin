//
//  ShaderEnumGeneratorCoreTests.swift
//  ShaderListPlugin
//
//  Created by Mateusz Kosikowski on 24/06/2025.
//

import Testing
@testable import ShaderEnumGeneratorCore

/// Compares two multi-line strings line-by-line, failing on the first mismatch with detailed diagnostics.
/// - Parameters:
///   - actual: The actual string output (e.g., generated code).
///   - expected: The expected string output.
///   - trimWhitespace: If true, trims leading/trailing whitespace before comparison.
///   - file: The file where the expectation is called (for test diagnostics).
///   - line: The line where the expectation is called (for test diagnostics).
//@_transparent
func expectCodeLinesEqual(
    _ actual: String,
    _ expected: String,
    trimWhitespace: Bool = false,
    sourceLocation: SourceLocation = #_sourceLocation
) {
    let actualLines = actual.split(separator: "\n", omittingEmptySubsequences: false).map(String.init)
    let expectedLines = expected.split(separator: "\n", omittingEmptySubsequences: false).map(String.init)
    
    // Check for line count mismatch first
    if actualLines.count != expectedLines.count {
        let message = """
        Line count mismatch.
        Expected: \(expectedLines.count) lines
        Actual:   \(actualLines.count) lines
        Actual Lines: \(actual)
        """
        #expect(false, Comment(rawValue: message), sourceLocation: sourceLocation)
        return
    }
    
    // Compare lines
    for (idx, (actualLine, expectedLine)) in zip(actualLines, expectedLines).enumerated() {
        let actualToCompare = trimWhitespace ? actualLine.trimmingCharacters(in: .whitespaces) : actualLine
        let expectedToCompare = trimWhitespace ? expectedLine.trimmingCharacters(in: .whitespaces) : expectedLine
        
        if actualToCompare != expectedToCompare {
            // Provide context: show up to 2 lines before and after the mismatch
            let startIdx = max(0, idx - 2)
            let endIdx = min(actualLines.count, idx + 3)
            let actualContext = actualLines[startIdx..<endIdx].map { "Actual:   \($0)" }.joined(separator: "\n")
            let expectedContext = expectedLines[startIdx..<endIdx].map { "Expected: \($0)" }.joined(separator: "\n")
            
            let message = """
            Line \(idx + 1) mismatch.
            Expected: \(expectedToCompare)
            Actual:   \(actualToCompare)
            Source Location: \(sourceLocation.line) [\(sourceLocation.fileID)]
            Context (lines \(startIdx + 1)-\(endIdx)):
            \(expectedContext)
            ---
            \(actualContext)
            """
            #expect(false, Comment(rawValue: message), sourceLocation: sourceLocation)
            return
        }
    }
}

@Suite("ShaderEnumGeneratorCore - Metal parsing and code generation")
struct ShaderEnumGeneratorCoreTests {
    @Test("Parses vertex and fragment shaders and generates expected enums")
    func testParseAndGenerate() async throws {
        let metalSource = """
        vertex float4 vertex_passthrough(float4 in [[stage_in]]) { return in; }
        fragment float4 fragment_main() { return float4(1); }
        kernel void kernel_func() { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 3)
        #expect(functions.contains(where: { $0.0 == "vertex" && $0.1 == "vertex_passthrough" }))
        #expect(functions.contains(where: { $0.0 == "fragment" && $0.1 == "fragment_main" }))
        #expect(functions.contains(where: { $0.0 == "kernel" && $0.1 == "kernel_func" }))
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions { grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name) }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum MTLComputeShader: String, CaseIterable {
                case kernel_func = "kernel_func"
            }
            public enum MTLFragmentShader: String, CaseIterable {
                case fragment_main = "fragment_main"
            }
            public enum MTLVertexShader: String, CaseIterable {
                case vertex_passthrough = "vertex_passthrough"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLComputeShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLFragmentShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }
        
        """)
    }

    @Test("Returns empty output if no shaders are found")
    func testNoShaders() async throws {
        let metalSource = "// No shader functions"
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions { grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name) }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // No shaders found.
        
        """)
    }

    @Test("Parses shaders with extra whitespace and newlines")
    func testParseIrregularWhitespace() async throws {
        let metalSource = """
        vertex\nfloat4\nvertex_newline(float4 in [[stage_in]]) { return in; }
        fragment\tfloat4\tfragment_tabbed ( ) { return float4(1); }
        kernel    void    kernel_spaced   ( ) { }
        compute\n   void\n   compute_mixed ( ) { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.contains(where: { $0.0 == "vertex" && $0.1 == "vertex_newline" }))
        #expect(functions.contains(where: { $0.0 == "fragment" && $0.1 == "fragment_tabbed" }))
        #expect(functions.contains(where: { $0.0 == "kernel" && $0.1 == "kernel_spaced" }))
        #expect(functions.contains(where: { $0.0 == "compute" && $0.1 == "compute_mixed" }))
        
        #expect(functions.count == 4)
    }

    @Test("Ignores leading/trailing whitespace in function declaration")
    func testParseLeadingTrailingWhitespace() async throws {
        let metalSource = """
          kernel   void    spaced_func    ( ) { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "kernel")
        #expect(functions[0].1 == "spaced_func")
    }
    
    @Test("Parses custom group comment and generates correct enum")
    func testCustomGroupComment() async throws {
        let metalSource = """
        //MTLShaderGroup: FancyShaderGroup
        kernel void customFunc() { }
        //MTLShaderGroup: Another
        fragment float4 otherFunc() { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions { grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name) }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum Another: String, CaseIterable {
                case otherFunc = "otherFunc"
            }
            public enum FancyShaderGroup: String, CaseIterable {
                case customFunc = "customFunc"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.Another) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }
        
        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.FancyShaderGroup) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }
    
    @Test("Parses custom group comment and generates correct enum")
    func testCustomGroupCommentWithWhitespaces() async throws {
        let metalSource = """
        //MTLShaderGroup: FancyShaderGroup
        vertex\n    float4\n    vertex_newline(float4 in [[stage_in]]) { return in; }
        //MTLShaderGroup: Another
        fragment\tfloat4\tfragment_tabbed ( ) { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions { grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name) }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum Another: String, CaseIterable {
                case fragment_tabbed = "fragment_tabbed"
            }
            public enum FancyShaderGroup: String, CaseIterable {
                case vertex_newline = "vertex_newline"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.Another) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }
        
        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.FancyShaderGroup) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }
        
        """)
    }
}

@Suite("ShaderEnumGeneratorCore - Extension Generation")
struct ShaderEnumGeneratorCoreExtensionTests {
    @Test("Generates enum and MTLLibrary extension for a single shader group")
    func testSingleGroupGeneratesExtension() async throws {
        let metalSource = "vertex float4 vertexMain() { return float4(1); }"
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code,
        """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum MTLVertexShader: String, CaseIterable {
                case vertexMain = "vertexMain"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }

    @Test("Generates all enums and MTLLibrary extensions for multiple shader groups")
    func testMultipleGroupsGenerateExtensions() async throws {
        let metalSource = """
        vertex float4 vertexFunc() { return float4(1); }
        fragment float4 fragmentFunc() { return float4(1); }
        kernel void kernelFunc() { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum MTLComputeShader: String, CaseIterable {
                case kernelFunc = "kernelFunc"
            }
            public enum MTLFragmentShader: String, CaseIterable {
                case fragmentFunc = "fragmentFunc"
            }
            public enum MTLVertexShader: String, CaseIterable {
                case vertexFunc = "vertexFunc"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLComputeShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLFragmentShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }
    
    @Test("Generates enum and MTLLibrary extension for custom shader group comment")
    func testCustomGroupCommentGeneratesExtension() async throws {
        let metalSource = """
        //MTLShaderGroup: CustomGroup
        kernel void customKernel() { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal
        
        public enum TestTargetMTLShaders {
            public enum CustomGroup: String, CaseIterable {
                case customKernel = "customKernel"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.CustomGroup) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }
}

