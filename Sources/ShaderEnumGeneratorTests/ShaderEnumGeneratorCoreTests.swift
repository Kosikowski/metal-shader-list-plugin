//
//  ShaderEnumGeneratorCoreTests.swift
//  ShaderListPlugin
//
//  Created by Mateusz Kosikowski on 24/06/2025.
//

import Testing
@testable import ShaderEnumGeneratorCore

/// Compares two multi-line strings line-by-line, failing on the first mismatch with detailed diagnostics.
/// - Parameters:
///   - actual: The actual string output (e.g., generated code).
///   - expected: The expected string output.
///   - trimWhitespace: If true, trims leading/trailing whitespace before comparison.
///   - file: The file where the expectation is called (for test diagnostics).
///   - line: The line where the expectation is called (for test diagnostics).
func expectCodeLinesEqual(
    _ actual: String,
    _ expected: String,
    trimWhitespace: Bool = false,
    sourceLocation: SourceLocation = #_sourceLocation
) {
    let actualLines = actual.split(separator: "\n", omittingEmptySubsequences: false).map(String.init)
    let expectedLines = expected.split(separator: "\n", omittingEmptySubsequences: false).map(String.init)

    // Check for line count mismatch first
    if actualLines.count != expectedLines.count {
        let message = """
        Line count mismatch.
        Expected: \(expectedLines.count) lines
        Actual:   \(actualLines.count) lines
        Actual Lines: \(actual)
        """
        #expect(Bool(false), Comment(rawValue: message), sourceLocation: sourceLocation)

        return
    }

    // Compare lines
    for (idx, (actualLine, expectedLine)) in zip(actualLines, expectedLines).enumerated() {
        let actualToCompare = trimWhitespace ? actualLine.trimmingCharacters(in: .whitespaces) : actualLine
        let expectedToCompare = trimWhitespace ? expectedLine.trimmingCharacters(in: .whitespaces) : expectedLine

        if actualToCompare != expectedToCompare {
            // Provide context: show up to 2 lines before and after the mismatch
            let startIdx = max(0, idx - 2)
            let endIdx = min(actualLines.count, idx + 3)
            let actualContext = actualLines[startIdx ..< endIdx].map { "Actual:   \($0)" }.joined(separator: "\n")
            let expectedContext = expectedLines[startIdx ..< endIdx].map { "Expected: \($0)" }.joined(separator: "\n")

            let message = """
            Line \(idx + 1) mismatch.
            Expected: \(expectedToCompare)
            Actual:   \(actualToCompare)
            Source Location: \(sourceLocation.line) [\(sourceLocation.fileID)]
            Context (lines \(startIdx + 1)-\(endIdx)):
            \(expectedContext)
            ---
            \(actualContext)
            """
            #expect(Bool(false), Comment(rawValue: message), sourceLocation: sourceLocation)
            return
        }
    }
}

// MARK: - ShaderEnumGeneratorCoreTests

@Suite("ShaderEnumGeneratorCore - Metal parsing and code generation")
struct ShaderEnumGeneratorCoreTests {
    @Test("Parses vertex and fragment shaders and generates expected enums")
    func parseAndGenerate() async throws {
        let metalSource = """
        vertex float4 vertex_passthrough(float4 in [[stage_in]]) { return in; }
        fragment float4 fragment_main() { return float4(1); }
        kernel void kernel_func() { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 3)
        #expect(functions.contains(where: { $0.0 == "vertex" && $0.1 == "vertex_passthrough" }))
        #expect(functions.contains(where: { $0.0 == "fragment" && $0.1 == "fragment_main" }))
        #expect(functions.contains(where: { $0.0 == "kernel" && $0.1 == "kernel_func" }))
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions {
            grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum MTLComputeShader: String, CaseIterable {
                case kernel_func = "kernel_func"
            }
            public enum MTLFragmentShader: String, CaseIterable {
                case fragment_main = "fragment_main"
            }
            public enum MTLVertexShader: String, CaseIterable {
                case vertex_passthrough = "vertex_passthrough"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLComputeShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLFragmentShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }

    @Test("Returns empty output if no shaders are found")
    func noShaders() async throws {
        let metalSource = "// No shader functions"
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions {
            grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // No shaders found.

        """)
    }

    @Test("Parses shaders with extra whitespace and newlines")
    func parseIrregularWhitespace() async throws {
        let metalSource = """
        vertex\nfloat4\nvertex_newline(float4 in [[stage_in]]) { return in; }
        fragment\tfloat4\tfragment_tabbed ( ) { return float4(1); }
        kernel    void    kernel_spaced   ( ) { }
        compute\n   void\n   compute_mixed ( ) { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.contains(where: { $0.0 == "vertex" && $0.1 == "vertex_newline" }))
        #expect(functions.contains(where: { $0.0 == "fragment" && $0.1 == "fragment_tabbed" }))
        #expect(functions.contains(where: { $0.0 == "kernel" && $0.1 == "kernel_spaced" }))
        #expect(functions.contains(where: { $0.0 == "compute" && $0.1 == "compute_mixed" }))

        #expect(functions.count == 4)
    }

    @Test("Ignores leading/trailing whitespace in function declaration")
    func parseLeadingTrailingWhitespace() async throws {
        let metalSource = """
          kernel   void    spaced_func    ( ) { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "kernel")
        #expect(functions[0].1 == "spaced_func")
    }

    @Test("Parses custom group comment and generates correct enum")
    func customGroupComment() async throws {
        let metalSource = """
        //MTLShaderGroup: FancyShaderGroup
        kernel void customFunc() { }
        //MTLShaderGroup: Another
        fragment float4 otherFunc() { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions {
            grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum Another: String, CaseIterable {
                case otherFunc = "otherFunc"
            }
            public enum FancyShaderGroup: String, CaseIterable {
                case customFunc = "customFunc"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.Another) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.FancyShaderGroup) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }

    @Test("Parses custom group comment and generates correct enum")
    func customGroupCommentWithWhitespaces() async throws {
        let metalSource = """
        //MTLShaderGroup: FancyShaderGroup
        vertex\n    float4\n    vertex_newline(float4 in [[stage_in]]) { return in; }
        //MTLShaderGroup: Another
        fragment\tfloat4\tfragment_tabbed ( ) { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions {
            grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum Another: String, CaseIterable {
                case fragment_tabbed = "fragment_tabbed"
            }
            public enum FancyShaderGroup: String, CaseIterable {
                case vertex_newline = "vertex_newline"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.Another) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.FancyShaderGroup) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }
}

// MARK: - ShaderEnumGeneratorCoreExtensionTests

@Suite("ShaderEnumGeneratorCore - Extension Generation")
struct ShaderEnumGeneratorCoreExtensionTests {
    @Test("Generates enum and MTLLibrary extension for a single shader group")
    func singleGroupGeneratesExtension() async throws {
        let metalSource = "vertex float4 vertexMain() { return float4(1); }"
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(
            code,
            """
            // Generated by ShaderEnumGenerator

            import Metal

            public enum TestTargetMTLShaders {
                public enum MTLVertexShader: String, CaseIterable {
                    case vertexMain = "vertexMain"
                }
            }

            extension MTLLibrary {
                public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                    makeFunction(name: shader.rawValue)
                }
            }

            """
        )
    }

    @Test("Generates all enums and MTLLibrary extensions for multiple shader groups")
    func multipleGroupsGenerateExtensions() async throws {
        let metalSource = """
        vertex float4 vertexFunc() { return float4(1); }
        fragment float4 fragmentFunc() { return float4(1); }
        kernel void kernelFunc() { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum MTLComputeShader: String, CaseIterable {
                case kernelFunc = "kernelFunc"
            }
            public enum MTLFragmentShader: String, CaseIterable {
                case fragmentFunc = "fragmentFunc"
            }
            public enum MTLVertexShader: String, CaseIterable {
                case vertexFunc = "vertexFunc"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLComputeShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLFragmentShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }

    @Test("Generates all enums and MTLLibrary extensions for multiple shader groups, and ignores commented code.")
    func multipleGroupsGenerateExtensionsWithCommentedOutCode() async throws {
        let metalSource = """
        vertex float4 vertexFunc() { return float4(1); }
        /*kernel void kernelFuncCoomentedOut() { }*/
        ///vertex float4 vertexFunc() { return float4(1); }
        fragment float4 fragmentFunc() { return float4(1); }
        kernel /*kernel void kernelFunc() { }*/ void /*comment*/ kernelFunc() { } // yet another one
        //   vertex float4 vertexFuncFuncCoomentedOut() { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum MTLComputeShader: String, CaseIterable {
                case kernelFunc = "kernelFunc"
            }
            public enum MTLFragmentShader: String, CaseIterable {
                case fragmentFunc = "fragmentFunc"
            }
            public enum MTLVertexShader: String, CaseIterable {
                case vertexFunc = "vertexFunc"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLComputeShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLFragmentShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.MTLVertexShader) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }

    @Test("Generates enum and MTLLibrary extension for custom shader group comment")
    func customGroupCommentGeneratesExtension() async throws {
        let metalSource = """
        //MTLShaderGroup: CustomGroup
        kernel void customKernel() { }
        """
        let functions = parseShaderFunctions(from: metalSource)
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        expectCodeLinesEqual(code, """
        // Generated by ShaderEnumGenerator

        import Metal

        public enum TestTargetMTLShaders {
            public enum CustomGroup: String, CaseIterable {
                case customKernel = "customKernel"
            }
        }

        extension MTLLibrary {
            public func makeFunction(_ shader: TestTargetMTLShaders.CustomGroup) -> MTLFunction? {
                makeFunction(name: shader.rawValue)
            }
        }

        """)
    }
}

// MARK: - ShaderEnumGeneratorComplexSignatureTests

@Suite("ShaderEnumGeneratorCore - Complex Shader Function Signatures")
struct ShaderEnumGeneratorComplexSignatureTests {
    @Test("Parses complex vertex shader with multiple parameters and attributes")
    func complexVertexShaderSignature() async throws {
        let metalSource = """
        vertex VertexOut vertex_main(
            const device VertexIn* vertices [[buffer(0)]],
            constant Uniforms& uniforms [[buffer(1)]],
            uint vertexID [[vertex_id]],
            uint instanceID [[instance_id]]
        ) {
            return VertexOut();
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_main")
    }

    @Test("Parses fragment shader with texture and sampler parameters")
    func fragmentShaderWithTextures() async throws {
        let metalSource = """
        fragment float4 fragment_main(
            VertexOut in [[stage_in]],
            texture2d<float> diffuseTexture [[texture(0)]],
            sampler diffuseSampler [[sampler(0)]],
            constant Uniforms& uniforms [[buffer(0)]]
        ) {
            return float4(1.0);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "fragment")
        #expect(functions[0].1 == "fragment_main")
    }

    @Test("Parses compute shader with threadgroup parameters")
    func computeShaderWithThreadgroups() async throws {
        let metalSource = """
        kernel void compute_main(
            device float* output [[buffer(0)]],
            device const float* input [[buffer(1)]],
            constant uint& count [[buffer(2)]],
            uint3 thread_position_in_grid [[thread_position_in_grid]],
            uint3 thread_position_in_threadgroup [[thread_position_in_threadgroup]],
            uint3 threadgroup_position_in_grid [[threadgroup_position_in_grid]]
        ) {
            // Compute logic
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "kernel")
        #expect(functions[0].1 == "compute_main")
    }

    @Test("Parses shader with template parameters")
    func shaderWithTemplateParameters() async throws {
        let metalSource = """
        template<typename T>
        vertex T vertex_template(
            const device T* vertices [[buffer(0)]],
            uint vertexID [[vertex_id]]
        ) {
            return vertices[vertexID];
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_template")
    }

    @Test("Parses shader with complex return type")
    func shaderWithComplexReturnType() async throws {
        let metalSource = """
        vertex VertexOut<MetalVertexFormat> vertex_complex(
            const device VertexIn* vertices [[buffer(0)]],
            uint vertexID [[vertex_id]]
        ) {
            return VertexOut<MetalVertexFormat>();
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_complex")
    }

    @Test("Parses multiple functions in same group")
    func multipleFunctionsInSameGroup() async throws {
        let metalSource = """
        //MTLShaderGroup: Lighting
        vertex float4 vertex_ambient() { return float4(1); }
        vertex float4 vertex_diffuse() { return float4(1); }
        vertex float4 vertex_specular() { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 3)
        #expect(functions.allSatisfy { $0.0 == "Lighting" })
        #expect(functions.map(\.1).sorted() == ["vertex_ambient", "vertex_diffuse", "vertex_specular"])
    }

    @Test("Handles shader functions with qualifiers and attributes")
    func shaderWithQualifiersAndAttributes() async throws {
        let metalSource = """
        [[visible]]
        vertex float4 vertex_visible(
            const device VertexIn* vertices [[buffer(0)]],
            uint vertexID [[vertex_id]]
        ) {
            return float4(1);
        }

        [[patch(patch_control_point_count)]]
        vertex float4 vertex_patch(
            patch_control_point<VertexIn> control_points [[patch_control_point]],
            uint patchID [[patch_id]]
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        #expect(functions.contains(where: { $0.1 == "vertex_visible" }))
        #expect(functions.contains(where: { $0.1 == "vertex_patch" }))
    }
}

// MARK: - ShaderEnumGeneratorRealWorldTests

@Suite("ShaderEnumGeneratorCore - Real-world Metal Shader Examples")
struct ShaderEnumGeneratorRealWorldTests {
    @Test("Parses complete Metal rendering pipeline shaders")
    func completeRenderingPipeline() async throws {
        let metalSource = """
        #include <metal_stdlib>
        using namespace metal;

        struct VertexIn {
            float4 position [[attribute(0)]];
            float2 texCoord [[attribute(1)]];
        };

        struct VertexOut {
            float4 position [[position]];
            float2 texCoord;
        };

        struct Uniforms {
            float4x4 mvp;
        };

        //MTLShaderGroup: BasicRendering
        vertex VertexOut vertex_basic(
            const device VertexIn* vertices [[buffer(0)]],
            constant Uniforms& uniforms [[buffer(1)]],
            uint vertexID [[vertex_id]]
        ) {
            VertexOut out;
            out.position = uniforms.mvp * vertices[vertexID].position;
            out.texCoord = vertices[vertexID].texCoord;
            return out;
        }

        fragment float4 fragment_basic(
            VertexOut in [[stage_in]],
            texture2d<float> diffuseTexture [[texture(0)]],
            sampler diffuseSampler [[sampler(0)]]
        ) {
            return diffuseTexture.sample(diffuseSampler, in.texCoord);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        #expect(functions.contains(where: { $0.0 == "BasicRendering" && $0.1 == "vertex_basic" }))
        #expect(functions.contains(where: { $0.0 == "BasicRendering" && $0.1 == "fragment_basic" }))
    }

    @Test("Parses compute shader for image processing")
    func imageProcessingComputeShader() async throws {
        let metalSource = """
        #include <metal_stdlib>
        using namespace metal;

        //MTLShaderGroup: ImageProcessing
        kernel void gaussian_blur_1d(
            texture2d<float, access::read> inputTexture [[texture(0)]],
            texture2d<float, access::write> outputTexture [[texture(1)]],
            constant float& sigma [[buffer(0)]],
            uint2 position [[thread_position_in_grid]]
        ) {
            // Gaussian blur implementation
        }

        kernel void sobel_edge_detection(
            texture2d<float, access::read> inputTexture [[texture(0)]],
            texture2d<float, access::write> outputTexture [[texture(1)]],
            uint2 position [[thread_position_in_grid]]
        ) {
            // Sobel edge detection
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        #expect(functions.allSatisfy { $0.0 == "ImageProcessing" })
        #expect(functions.contains(where: { $0.1 == "gaussian_blur_1d" }))
        #expect(functions.contains(where: { $0.1 == "sobel_edge_detection" }))
    }

    @Test("Parses tessellation shaders")
    func tessellationShaders() async throws {
        let metalSource = """
        #include <metal_stdlib>
        using namespace metal;

        //MTLShaderGroup: Tessellation
        [[patch(patch_control_point_count)]]
        vertex float4 tessellation_vertex(
            patch_control_point<VertexIn> control_points [[patch_control_point]],
            uint patchID [[patch_id]]
        ) {
            return float4(1);
        }

        [[patch(patch_control_point_count)]]
        vertex float4 tessellation_vertex_post(
            patch_control_point<VertexIn> control_points [[patch_control_point]],
            uint patchID [[patch_id]]
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 2)
        #expect(functions.allSatisfy { $0.0 == "Tessellation" })
        #expect(functions.contains(where: { $0.1 == "tessellation_vertex" }))
        #expect(functions.contains(where: { $0.1 == "tessellation_vertex_post" }))
    }

    @Test("Parses ray tracing shaders")
    func rayTracingShaders() async throws {
        let metalSource = """
        #include <metal_stdlib>
        using namespace metal;

        //MTLShaderGroup: RayTracing
        [[visible]]
        vertex float4 ray_generation_vertex(
            const device VertexIn* vertices [[buffer(0)]],
            uint vertexID [[vertex_id]]
        ) {
            return float4(1);
        }

        [[visible]]
        fragment float4 ray_generation_fragment(
            float4 position [[position]],
            float2 texCoord [[stage_in]]
        ) {
            return float4(1);
        }

        [[visible]]
        kernel void ray_intersection(
            device RayPayload* payload [[buffer(0)]],
            uint rayID [[thread_position_in_grid]]
        ) {
            // Ray intersection logic
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 3)
        #expect(functions.allSatisfy { $0.0 == "RayTracing" })
        #expect(functions.contains(where: { $0.1 == "ray_generation_vertex" }))
        #expect(functions.contains(where: { $0.1 == "ray_generation_fragment" }))
        #expect(functions.contains(where: { $0.1 == "ray_intersection" }))
    }
}

// MARK: - ShaderEnumGeneratorEdgeCaseTests

@Suite("ShaderEnumGeneratorCore - Edge Cases and Error Handling")
struct ShaderEnumGeneratorEdgeCaseTests {
    @Test("Handles malformed function declarations gracefully")
    func malformedFunctionDeclarations() async throws {
        let metalSource = """
        vertex // missing return type and function name
        fragment float4 // missing function name
        kernel void // missing function name and parameters
        compute // incomplete declaration
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.isEmpty)
    }

    @Test("Handles nested function declarations")
    func nestedFunctionDeclarations() async throws {
        let metalSource = """
        vertex float4 outer_function() {
            void inner_function() {
                // This should not be parsed as a shader function
            }
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "outer_function")
    }

    @Test("Handles function-like macros")
    func functionLikeMacros() async throws {
        let metalSource = """
        #define VERTEX_FUNC(name) vertex float4 name() { return float4(1); }
        VERTEX_FUNC(macro_generated)

        vertex float4 real_function() { return float4(1); }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "real_function")
    }

    @Test("Handles shader functions with default parameters")
    func shaderWithDefaultParameters() async throws {
        let metalSource = """
        vertex float4 vertex_with_defaults(
            const device VertexIn* vertices [[buffer(0)]],
            uint vertexID [[vertex_id]] = 0
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_with_defaults")
    }

    @Test("Handles shader functions with variadic parameters")
    func shaderWithVariadicParameters() async throws {
        let metalSource = """
        vertex float4 vertex_variadic(
            const device VertexIn* vertices [[buffer(0)]],
            uint vertexID [[vertex_id]],
            ...
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_variadic")
    }

    @Test("Handles shader functions with constexpr parameters")
    func shaderWithConstexprParameters() async throws {
        let metalSource = """
        vertex float4 vertex_constexpr(
            const device VertexIn* vertices [[buffer(0)]],
            constexpr uint bufferIndex = 0
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_constexpr")
    }

    @Test("Handles shader functions with reference parameters")
    func shaderWithReferenceParameters() async throws {
        let metalSource = """
        vertex float4 vertex_reference(
            const device VertexIn& vertex [[buffer(0)]],
            constant Uniforms& uniforms [[buffer(1)]]
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_reference")
    }

    @Test("Handles shader functions with pointer parameters")
    func shaderWithPointerParameters() async throws {
        let metalSource = """
        vertex float4 vertex_pointer(
            const device VertexIn* vertices [[buffer(0)]],
            device float* output [[buffer(1)]]
        ) {
            return float4(1);
        }
        """
        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == 1)
        #expect(functions[0].0 == "vertex")
        #expect(functions[0].1 == "vertex_pointer")
    }
}

// MARK: - ShaderEnumGeneratorPerformanceTests

@Suite("ShaderEnumGeneratorCore - Performance and Large Files")
struct ShaderEnumGeneratorPerformanceTests {
    @Test("Handles large shader file with many functions")
    func largeShaderFile() async throws {
        var metalSource = ""
        let functionCount = 100

        // Generate many shader functions
        for i in 0 ..< functionCount {
            metalSource += """
            vertex float4 vertex_\(i)(
                const device VertexIn* vertices [[buffer(0)]],
                uint vertexID [[vertex_id]]
            ) {
                return float4(1);
            }

            fragment float4 fragment_\(i)(
                float4 position [[position]]
            ) {
                return float4(1);
            }

            """
        }

        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == functionCount * 2)

        // Test enum generation with many functions
        var grouped: [ShaderGroup: Set<String>] = [:]
        for (groupName, funcName) in functions {
            grouped[ShaderGroup.from(rawValue: groupName), default: []].insert(funcName)
        }

        let code = generateShaderEnums(functionsByType: grouped, moduleName: "LargeTest")
        #expect(!code.isEmpty)
        #expect(code.contains("LargeTestMTLShaders"))
    }

    @Test("Handles shader file with many custom groups")
    func manyCustomGroups() async throws {
        var metalSource = ""
        let groupCount = 50

        // Generate many custom groups with valid names
        let groupNames = ["Lighting", "Rendering", "PostProcessing", "Effects", "Utilities", "Core", "Advanced", "Basic", "Complex", "Simple"]

        for i in 0 ..< groupCount {
            let groupName = groupNames[i % groupNames.count] + String(Character(UnicodeScalar(65 + (i % 26))!)) // A-Z
            metalSource += """
            //MTLShaderGroup: \(groupName)
            vertex float4 vertex_group\(i)() { return float4(1); }
            fragment float4 fragment_group\(i)() { return float4(1); }

            """
        }

        let functions = parseShaderFunctions(from: metalSource)
        #expect(functions.count == groupCount * 2) // 2 functions per group

        var grouped: [ShaderGroup: Set<String>] = [:]
        for (enumName, name) in functions {
            grouped[ShaderGroup.from(rawValue: enumName), default: []].insert(name)
        }
        let code = generateShaderEnums(functionsByType: grouped, moduleName: "TestTarget")
        #expect(code.contains("// Generated by ShaderEnumGenerator"))
        #expect(code.contains("public enum TestTargetMTLShaders"))
    }

    // MARK: - Shader Group Name Validation Tests

    @Test("Validates shader group names with only A-Z and a-z characters")
    func validateValidShaderGroupNames() async throws {
        let validNames = [
            "Lighting",
            "Rendering",
            "PostProcessing",
            "Effects",
            "Utilities",
            "Core",
            "Advanced",
            "Basic",
            "Complex",
            "Simple",
            "ValidName",
            "AnotherValidName",
            "A",
            "Z",
            "a",
            "z",
        ]

        for name in validNames {
            do {
                try validateShaderGroupName(name)
                // Should not throw
            } catch {
                #expect(Bool(false), Comment("Valid name '\(name)' should not throw error: \(error)"))
            }
        }
    }

    @Test("Rejects shader group names with invalid characters")
    func validateInvalidShaderGroupNames() async throws {
        let invalidTestCases = [
            ("Lighting-3D", "hyphen"),
            ("Post_Processing", "underscore"),
            ("123Invalid", "starts with number"),
            ("Invalid-Name", "hyphen"),
            ("Name_With_Underscore", "underscore"),
            ("Name With Space", "space"),
            ("Name\tWith\tTab", "tab"),
            ("Name\nWith\nNewline", "newline"),
            ("Name@With@Symbol", "at symbol"),
            ("Name#With#Hash", "hash symbol"),
            ("Name$With$Dollar", "dollar symbol"),
            ("Name%With%Percent", "percent symbol"),
            ("Name^With^Caret", "caret symbol"),
            ("Name&With&Ampersand", "ampersand"),
            ("Name*With*Star", "asterisk"),
            ("Name(With(Parens", "parentheses"),
            ("Name)With)Parens", "parentheses"),
            ("Name[With[Brackets", "brackets"),
            ("Name]With]Brackets", "brackets"),
            ("Name{With{Braces", "braces"),
            ("Name}With}Braces", "braces"),
            ("Name|With|Pipe", "pipe"),
            ("Name\\With\\Backslash", "backslash"),
            ("Name/With/ForwardSlash", "forward slash"),
            ("Name:With:Colon", "colon"),
            ("Name;With;Semicolon", "semicolon"),
            ("Name\"With\"Quotes", "quotes"),
            ("Name'With'SingleQuote", "single quote"),
            ("Name`With`Backtick", "backtick"),
            ("Name~With~Tilde", "tilde"),
            ("Name+With+Plus", "plus"),
            ("Name=With=Equals", "equals"),
            ("Name<With<LessThan", "less than"),
            ("Name>With>GreaterThan", "greater than"),
            ("Name,With,Comma", "comma"),
            ("Name.With.Period", "period"),
            ("Name?With?Question", "question mark"),
            ("Name!With!Exclamation", "exclamation mark"),
        ]

        for (name, description) in invalidTestCases {
            do {
                try validateShaderGroupName(name)
                #expect(Bool(false), Comment("Invalid name '\(name)' with \(description) should throw error"))
            } catch {
                // Expected to throw
                let errorMessage = error.localizedDescription
                #expect(errorMessage.contains("Invalid shader group name"))
                #expect(errorMessage.contains("Only A-Z and a-z characters are allowed"))
            }
        }
    }

    @Test("Rejects empty shader group names")
    func validateEmptyShaderGroupNames() async throws {
        let emptyNames = [
            "",
            "   ",
            "\t",
            "\n",
            "\r",
            "\r\n",
            "  \t  \n  ",
        ]

        for name in emptyNames {
            do {
                try validateShaderGroupName(name)
                #expect(Bool(false), Comment("Empty name '\(name)' should throw error"))
            } catch {
                // Expected to throw
                let errorMessage = error.localizedDescription
                #expect(errorMessage.contains("Shader group name cannot be empty"))
            }
        }
    }

    @Test("Validates shader group names in actual Metal shader content")
    func validateShaderGroupNamesInContent() async throws {
        let validMetalSource = """
        //MTLShaderGroup: Lighting
        vertex float4 vertex_main() { return float4(0.0); }

        //MTLShaderGroup: Rendering
        fragment float4 fragment_main() { return float4(1.0); }

        //MTLShaderGroup: ValidName
        compute void compute_main() { }
        """

        // Should not throw
        try validateShaderGroupNames(in: validMetalSource)
    }

    @Test("Rejects invalid shader group names in actual Metal shader content")
    func validateInvalidShaderGroupNamesInContent() async throws {
        let invalidMetalSource = """
        //MTLShaderGroup: Lighting
        vertex float4 vertex_main() { return float4(0.0); }

        //MTLShaderGroup: Invalid-Name
        fragment float4 fragment_main() { return float4(1.0); }

        //MTLShaderGroup: Post_Processing
        compute void compute_main() { }
        """

        do {
            try validateShaderGroupNames(in: invalidMetalSource)
            #expect(Bool(false), Comment("Should throw error for invalid group names"))
        } catch {
            // Expected to throw
            let errorMessage = error.localizedDescription
            #expect(errorMessage.contains("Invalid shader group name"))
            #expect(errorMessage.contains("Invalid-Name") || errorMessage.contains("Post_Processing"))
        }
    }

    @Test("Integration test: parseShaderFunctions throws on invalid group names")
    func parseShaderFunctionsThrowsOnInvalidGroupNames() async throws {
        let invalidMetalSource = """
        //MTLShaderGroup: ValidName
        vertex float4 vertex_main() { return float4(0.0); }

        //MTLShaderGroup: Invalid-Name
        fragment float4 fragment_main() { return float4(1.0); }
        """

        // Note: parseShaderFunctions calls exit(1) on validation errors, so we can't test it directly
        // The validation is tested separately in validateInvalidShaderGroupNamesInContent()
        // This test is kept for documentation but doesn't actually test throwing behavior

        // Instead, test that validateShaderGroupNames throws for invalid content
        do {
            try validateShaderGroupNames(in: invalidMetalSource)
            #expect(Bool(false), Comment("validateShaderGroupNames should throw for invalid group names"))
        } catch {
            // Expected to throw
            let errorMessage = error.localizedDescription
            #expect(errorMessage.contains("Invalid shader group name"))
        }
    }

    @Test("Integration test: parseShaderFunctions works with valid group names")
    func parseShaderFunctionsWorksWithValidGroupNames() async throws {
        let validMetalSource = """
        //MTLShaderGroup: Lighting
        vertex float4 vertex_main() { return float4(0.0); }

        //MTLShaderGroup: Rendering
        fragment float4 fragment_main() { return float4(1.0); }

        //MTLShaderGroup: ValidName
        compute void compute_main() { }
        """

        // Should not throw
        let functions = parseShaderFunctions(from: validMetalSource)
        #expect(functions.count == 3)
        #expect(functions.contains(where: { $0.0 == "Lighting" && $0.1 == "vertex_main" }))
        #expect(functions.contains(where: { $0.0 == "Rendering" && $0.1 == "fragment_main" }))
        #expect(functions.contains(where: { $0.0 == "ValidName" && $0.1 == "compute_main" }))
    }
}
